sequenceDiagram

actor Channel
participant GW as API_Connect
participant CS as sgt_carsec_cardsecuritymx
participant CPL as sgt_cardpl_cardplacelocator

participant Cipher as cipher_service

participant MQIN as IBM_MQ_IN
participant MQOUT as IBM_MQ_OUT
participant Gravity as Gravity_CICS
participant Core as Core_Bancario
participant Disp as Dispatcher_Service
participant Redis as Redis_PubSub

participant PLJWKS as PLARD_JWKS_4_0_0
participant PLARD as PLARD_API_4_0_0

%% BOOTSTRAP
Note over CS,Redis: BOOTSTRAP_SUBSCRIBE_ONCE
CS->>Redis: SUBSCRIBE cardsec_trx_responses

%% REQUEST
Channel->>GW: POST change_pin inbound_JWE plus JWSID
GW->>GW: validate JWSID
GW->>CS: forward inbound_JWE

Note over CS: CS never opens inbound_JWE
CS->>CPL: resolvePlace card_id
CPL-->>CS: place GRAVITY or PLARD

alt place GRAVITY

  Note over CS,Disp: GRAVITY_TRX_FLOW
  CS->>MQIN: LMPB request corrId1 card_id
  MQIN->>Gravity: deliver LMPB
  Gravity->>Core: execute LMPB
  Core-->>Gravity: dynamicKey keyId
  Gravity-->>MQOUT: LMPB response corrId1 dynamicKey keyId

  MQOUT-->>Disp: read corrId1 dynamicKey keyId
  Disp->>Redis: PUBLISH cardsec_trx_responses corrId1 dynamicKey keyId

  Redis-->>CS: message corrId1 dynamicKey keyId
  CS->>Cipher: encryptPinblockWithDynamicKey inbound_JWE dynamicKey
  Cipher-->>CS: pinblockEncrypted

  CS->>MQIN: LMPC request corrId2 card_id pinblockEncrypted keyId
  MQIN->>Gravity: deliver LMPC
  Gravity->>Core: execute LMPC
  Core-->>Gravity: status code
  Gravity-->>MQOUT: LMPC response corrId2 status code

  MQOUT-->>Disp: read corrId2 status code
  Disp->>Redis: PUBLISH cardsec_trx_responses corrId2 status code

  Redis-->>CS: message corrId2 status code
  CS->>Cipher: encryptResponseForChannel status code inbound_JWE
  Cipher-->>CS: outbound_JWE
  CS-->>GW: outbound_JWE
  GW-->>Channel: outbound_JWE

else place PLARD

  Note over CS,PLARD: PLARD_API_FLOW_DETAILED

  %% Step 0 get PLARD jwks
  CS->>PLJWKS: GET jwks
  PLJWKS-->>CS: kidPlardEnc plardPublicKey

  %% Step 1 generate ephemeral key pair for PEK response
  CS->>Cipher: generateEphemeralKeyPair purpose PEK_response
  Cipher-->>CS: pekEphemeralPublicKey pekEphemeralKeyId

  %% Step 2 build PEK request payload and wrap it
  Note over CS,Cipher: PEK_request_payload uses Generate_pek_input_structure\nand includes pekEphemeralPublicKey\nCipher builds JWE encrypted with PLARD jwks kidPlardEnc\nCipher signs JWS using signingKeyId from Cipher JKS

  CS->>Cipher: buildPEKRequestJwsJwe inbound_JWE kidPlardEnc plardPublicKey signingKeyId pekEphemeralPublicKey
  Cipher-->>CS: pekAuthJWS jwePEKReq

  %% Step 3 call PEK endpoint in PLARD
  CS->>PLARD: POST dynamic_pek Authorization pekAuthJWS kidPlardEnc body jwePEKReq
  PLARD-->>CS: jwePEKResp

  %% Step 4 decrypt PEK response to get PEK assigned
  CS->>Cipher: decryptPEKResponse jwePEKResp pekEphemeralKeyId
  Cipher-->>CS: pekKey pekToken

  %% Step 5 use PEK key and original inbound JWE to produce encrypted pinblock json
  Note over CS,Cipher: Cipher opens inbound_JWE internally\nCS never sees clear data\nCipher returns json with encrypted pinblock plus pekToken

  CS->>Cipher: encryptPinblockWithPEK inbound_JWE pekKey
  Cipher-->>CS: jsonWithEncryptedPinblock pekToken

  %% Step 6 build ChangePin request structure and wrap as JWS and JWE
  Note over CS,Cipher: ChangePin_input_structure includes\njsonWithEncryptedPinblock and pekToken\nCipher encrypts with PLARD jwks kidPlardEnc\nCipher signs JWS with signingKeyId in Cipher JKS

  CS->>Cipher: buildChangePinRequestJwsJwe card_id jsonWithEncryptedPinblock pekToken kidPlardEnc plardPublicKey signingKeyId
  Cipher-->>CS: plardAuthJWS2 jweChangePinReq

  %% Step 7 call PLARD change_pin
  CS->>PLARD: POST change_pin Authorization plardAuthJWS2 kidPlardEnc body jweChangePinReq
  PLARD-->>CS: jweChangePinResp

  %% Step 8 reencrypt response to channel using inbound JWE
  CS->>Cipher: reencryptPlardResponseForChannel jweChangePinResp inbound_JWE
  Cipher-->>CS: outbound_JWE
  CS-->>GW: outbound_JWE
  GW-->>Channel: outbound_JWE

end
