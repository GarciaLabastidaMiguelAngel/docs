sequenceDiagram
    autonumber
    participant Client as API Consumer
    participant APIC as API Connect (Gateway)
    participant MS as Microservice
    participant Redis as Redis (Cache + Pub/Sub)
    participant MQIN as MQ (Queue IN)
    participant Host as Mainframe (PS7/DDF)
    participant MQOUT as MQ (Queue OUT)
    participant Disp as Message Dispatcher

    %% ---------- Startup ----------
    par MS startup
        MS->>Redis: SUBSCRIBE ms_channel_unique
    and Dispatcher startup
        Disp->>MQOUT: Start LISTENER on MQ-OUT
    end

    %% ---------- Entry & security ----------
    Client->>APIC: HTTPS (mTLS) + JWSID (aud=channel) + JSON {includeAddresses, includePhones, includeEmails, page*, size*}
    APIC->>APIC: Validate JWSID, mTLS, rate limits
    APIC->>APIC: Change audience → new JWSID (aud=MS)
    APIC->>MS: HTTPS (mTLS) + JWSID (aud=MS) + JSON (filters)
    MS->>MS: Validate JWSID (own audience)
    MS->>MS: Parse filters → flags (addr, ph, em) and pagination params

    %% ---------- Conditional parallel orchestration ----------
    par (1) IF includeAddresses=true → PE62 (cacheable 5 min)
        opt includeAddresses
            MS->>Redis: GET trx:pe62:address:{customerId}
            alt MISS
                MS->>MS: corrId = new()
                MS->>MQIN: Put(PS7 PE62, corrId)
                MQIN-->>Host: Get PE62
                Host-->>MQOUT: Put(PE62 Response, corrId)
                MQOUT-->>Disp: Get
                Disp-->>MS: Push PE62 Response
                MS->>Redis: SETEX trx:pe62:address:{customerId}, 300, JSON
            else HIT
                Redis-->>MS: JSON (cache)
            end

            %% Address-driven catalogs (TCGG 1.1–1.4, 24h cache)
            loop For each address returned by PE62
                par TCGG 1.1..1.4
                    MS->>Redis: GET cat:tcgg:country_code
                    alt MISS
                        MS->>MQIN: Put(PS7 TCGG getCountryCode)
                        Host-->>MQOUT: Response
                        Disp-->>MS: Push
                        MS->>Redis: SETEX cat:tcgg:country_code, 86400, JSON
                    else HIT
                        Redis-->>MS: JSON
                    end

                    MS->>Redis: GET cat:tcgg:state_code
                    alt MISS
                        MS->>MQIN: Put(PS7 TCGG getStateCode)
                        Host-->>MQOUT: Response
                        Disp-->>MS: Push
                        MS->>Redis: SETEX cat:tcgg:state_code, 86400, JSON
                    else HIT
                        Redis-->>MS: JSON
                    end

                    MS->>Redis: GET cat:tcgg:settlement_type_code
                    alt MISS
                        MS->>MQIN: Put(PS7 TCGG getSettlementTypeCode)
                        Host-->>MQOUT: Response
                        Disp-->>MS: Push
                        MS->>Redis: SETEX cat:tcgg:settlement_type_code, 86400, JSON
                    else HIT
                        Redis-->>MS: JSON
                    end

                    MS->>Redis: GET cat:tcgg:use_type_code
                    alt MISS
                        MS->>MQIN: Put(PS7 TCGG getUseTypeCode)
                        Host-->>MQOUT: Response
                        Disp-->>MS: Push
                        MS->>Redis: SETEX cat:tcgg:use_type_code, 86400, JSON
                    else HIT
                        Redis-->>MS: JSON
                    end
                end
            end
        end

    and (2) IF includePhones=true → PECD (paginated, cacheable 5 min)
        opt includePhones
            MS->>Redis: GET trx:pecd:phones:{customerId}:{pageKey}
            alt MISS
                loop while more pages (per page/size)
                    MS->>MS: corrId = new()
                    MS->>MQIN: Put(PS7 PECD, corrId)
                    MQIN-->>Host: Get
                    Host-->>MQOUT: Put(PECD Response, corrId)
                    MQOUT-->>Disp: Get
                    Disp-->>MS: Push PECD Response
                end
                MS->>Redis: SETEX trx:pecd:phones:{customerId}:{pageKey}, 300, JSON
            else HIT
                Redis-->>MS: JSON (cache)
            end
        end

    and (3) IF includeEmails=true → PECH (paginated, cacheable 5 min)
        opt includeEmails
            MS->>Redis: GET trx:pech:emails:{customerId}:{pageKey}
            alt MISS
                loop while more pages (per page/size)
                    MS->>MS: corrId = new()
                    MS->>MQIN: Put(PS7 PECH, corrId)
                    MQIN-->>Host: Get
                    Host-->>MQOUT: Put(PECH Response, corrId)
                    MQOUT-->>Disp: Get
                    Disp-->>MS: Push PECH Response
                end
                MS->>Redis: SETEX trx:pech:emails:{customerId}:{pageKey}, 300, JSON
            else HIT
                Redis-->>MS: JSON (cache)
            end
        end

    and (4) IF includePhones OR includeEmails → TCGG table 1521 (usage catalog, 24 h)
        opt includePhones or includeEmails
            MS->>Redis: GET cat:tcgg:1521
            alt MISS
                MS->>MQIN: Put(PS7 TCGG table=1521)
                MQIN-->>Host: Get
                Host-->>MQOUT: Put(Response)
                MQOUT-->>Disp: Get
                Disp-->>MS: Push Response
                MS->>Redis: SETEX cat:tcgg:1521, 86400, JSON
            else HIT
                Redis-->>MS: JSON (cache)
            end

            %% Conditional DDF execution based on flags
            par DDF 4.1 – UseEmail (codes + desc)
                opt includeEmails
                    MS->>Redis: GET ddf:use_email
                    alt MISS
                        MS->>Host: Query DDF UseEmail (codes)
                        Host-->>MS: JSON codes
                        MS->>Redis: SETEX ddf:use_email, 86400, JSON
                    else HIT
                        Redis-->>MS: JSON codes
                    end
                    loop for each email_use_code
                        MS->>Redis: GET ddf:use_email:desc:{code}
                        alt MISS
                            MS->>Host: Query DDF UseEmail description({code})
                            Host-->>MS: JSON desc
                            MS->>Redis: SETEX ddf:use_email:desc:{code}, 86400, JSON
                        else HIT
                            Redis-->>MS: JSON desc
                        end
                    end
                end
            and DDF 4.2 – UsePhone (codes + desc)
                opt includePhones
                    MS->>Redis: GET ddf:use_phone
                    alt MISS
                        MS->>Host: Query DDF UsePhone (codes)
                        Host-->>MS: JSON codes
                        MS->>Redis: SETEX ddf:use_phone, 86400, JSON
                    else HIT
                        Redis-->>MS: JSON codes
                    end
                    loop for each phone_use_code
                        MS->>Redis: GET ddf:use_phone:desc:{code}
                        alt MISS
                            MS->>Host: Query DDF UsePhone description({code})
                            Host-->>MS: JSON desc
                            MS->>Redis: SETEX ddf:use_phone:desc:{code}, 86400, JSON
                        else HIT
                            Redis-->>MS: JSON desc
                        end
                    end
                end
            end
        end
    end

    %% ---------- Response ----------
    MS->>MS: Build DTO with requested sections (addr/phones/emails)
    MS-->>APIC: HTTPS 200 + JSON
    APIC-->>Client: HTTPS 200 + JSON

    %% ---------- Notes ----------
    note over Client,APIC: All communication via HTTPS (mTLS) + JWSID authentication.
    note over APIC,MS: APIC reissues JWSID with new audience; MS validates it.
    note over MS,Host: PS7 for transactions (PE62, PECD, PECH, TCGG); DDF for direct reads.
    note over MS,Redis: TTL = 300 s for transactions; 86400 s for catalogs/DDFs.
    note over MS: TCGG table 1521 and DDFs execute **only** if includePhones or includeEmails are true.
